"""
Meeting article generator for Jekyll sites.

Generates Jekyll-formatted meeting articles from analyzed topic data.
Creates LLM prompts for article generation and prepares Jekyll front matter.

The pipeline:
1. Reads topic analysis JSON (from analyzer)
2. Builds metadata (meeting info, duration)
3. Generates structured LLM prompt
4. Outputs Jekyll draft template for manual completion
"""

import argparse
import json
import sys
import unicodedata
from pathlib import Path
from datetime import datetime

import yaml


# =========================
# CONFIG
# =========================

# Default layout for Jekyll
DEFAULT_LAYOUT = "meeting"

# Default output files
DEFAULT_PROMPT_FILE = "llm_prompt.txt"
DEFAULT_JEKYLL_DRAFT = "jekyll_draft.md"


# =========================
# HELPERS
# =========================

def _normalize_text(text):
    """
    Normalize Unicode text by removing diacritics.

    Args:
        text: Text to normalize (str)

    Returns:
        str: Normalized lowercase text without diacritics
    """
    text = unicodedata.normalize("NFKD", text)
    text = "".join(c for c in text if not unicodedata.combining(c))
    return text.lower()


# =========================
# METADATA GENERATION
# =========================

def build_meeting_metadata(topics, meeting_date, meeting_number, layout=DEFAULT_LAYOUT):
    """
    Build Jekyll front matter metadata from topics.

    Metadata is NEVER generated by LLM - it's deterministic from input data.

    Args:
        topics: List of topic dicts from analyzer
        meeting_date: Meeting date in YYYY-MM-DD format (str)
        meeting_number: Meeting sequence number (int)
        layout: Jekyll layout name (str)

    Returns:
        dict: Jekyll front matter fields:
            - layout: Jekyll layout name
            - title: Page title
            - meeting_date: Date in YYYY-MM-DD
            - meeting_number: Meeting sequence number
            - meeting_duration: Human readable duration (e.g., "2 h 15 min")
            - meeting_duration_minutes: Total duration in minutes
    """
    # Calculate total duration from topics
    total_minutes = int(sum(t.get("time_minutes", 0) for t in topics))
    hours = total_minutes // 60
    minutes = total_minutes % 60

    return {
        "layout": layout,
        "title": f"Jedn√°n√≠ zastupitelstva ‚Äì {meeting_date}",
        "meeting_date": meeting_date,
        "meeting_number": meeting_number,
        "meeting_duration": f"{hours} h {minutes} min",
        "meeting_duration_minutes": total_minutes,
    }


# =========================
# TOPIC PREPARATION
# =========================

def prepare_topics_for_llm(topics, max_evidence=3):
    """
    Prepare topics for LLM consumption.

    Ensures deterministic, sorted, limited input to LLM.

    Args:
        topics: List of topic dicts from analyzer
        max_evidence: Maximum evidence sentences per topic (int)

    Returns:
        list[dict]: Prepared topics with:
            - order: Topic ranking by importance
            - time_minutes: Duration spent on topic
            - topic_type: "monologue", "discussion", or "procedural"
            - topic_hint: Domain hint for topic
            - evidence: Representative sentences (limited to max_evidence)
    """
    prepared = []

    for topic in sorted(topics, key=lambda x: x.get("order", 0)):
        prepared.append({
            "order": topic.get("order"),
            "time_minutes": round(topic.get("time_minutes", 0), 1),
            "topic_type": topic.get("topic_type"),
            "topic_hint": topic.get("topic_hint"),
            "evidence": topic.get("evidence", [])[:max_evidence],
        })

    return prepared


# =========================
# LLM PROMPT GENERATION
# =========================

def build_llm_prompt(prepared_topics):
    """
    Build structured prompt for LLM article generation.

    The LLM:
    - Does NOT know about Jekyll
    - Does NOT know about sections/structure
    - Does NOT know about metadata (already generated)
    - Only writes continuous text

    Args:
        prepared_topics: Prepared topics from prepare_topics_for_llm()

    Returns:
        str: Complete LLM prompt with instructions and data
    """
    return f"""
Jsi redaktor region√°ln√≠ho zpravodajstv√≠.
P√≠≈°e≈° vƒõcn√Ω a neutr√°ln√≠ ƒçl√°nek o pr≈Øbƒõhu jedn√°n√≠ zastupitelstva.

Pravidla:
- pi≈° SOUVISL√ù TEXT, bez nadpis≈Ø a sekc√≠
- postupuj chronologicky podle po≈ôad√≠ t√©mat
- zohledni, kolik ƒçasu bylo jednotliv√Ωm t√©mat≈Øm vƒõnov√°no
- u ka≈æd√©ho t√©matu struƒçnƒõ vysvƒõtli, ƒçeho se t√Ωkalo
- zmi≈à, zda ≈°lo o diskuzi, procedur√°ln√≠ bod nebo vystoupen√≠ jednotlivce
- nep≈ôid√°vej ≈æ√°dn√° fakta, jm√©na ani ƒç√≠sla, kter√° nejsou v podkladech
- nic nehodno≈•, pouze popisuj

Podklady (se≈ôazeno podle v√Ωznamu):

{json.dumps(prepared_topics, ensure_ascii=False, indent=2)}
""".strip()


# =========================
# JEKYLL OUTPUT
# =========================

def build_jekyll_draft(metadata, summary_placeholder="<<< VLO≈Ω SHRNUT√ç (3-4 VƒöTY) >>>", article_placeholder="<<< VLO≈Ω TEXT ƒåL√ÅNKU ZDE >>>"):
    """
    Build Jekyll page draft with metadata and placeholders.

    Creates a valid Jekyll front matter page ready for manual completion.

    Args:
        metadata: Metadata dict from build_meeting_metadata()
        summary_placeholder: Placeholder text for summary (str)
        article_placeholder: Placeholder text for article body (str)

    Returns:
        str: Complete Jekyll page with YAML front matter and placeholders
    """
    header = dict(metadata)
    header["summary"] = summary_placeholder

    # Generate YAML front matter
    yaml_text = yaml.safe_dump(
        header,
        allow_unicode=True,
        sort_keys=False,
        width=80
    )

    # Combine front matter and body
    content = (
        f"---\n{yaml_text}---\n\n"
        f"{article_placeholder}\n"
    )

    return content


# =========================
# MAIN PIPELINE
# =========================

def generate_article(
    topics_file,
    meeting_date,
    meeting_number,
    output_dir=None,
    layout=DEFAULT_LAYOUT,
    prompt_file=None,
    jekyll_file=None
):
    """
    Generate meeting article prompt and Jekyll template.

    Process:
    1. Load topics from analyzer output
    2. Build deterministic metadata
    3. Prepare topics for LLM
    4. Generate LLM prompt
    5. Create Jekyll draft template

    Args:
        topics_file: Path to topics JSON from analyzer (Path or str)
        meeting_date: Meeting date in YYYY-MM-DD format (str)
        meeting_number: Meeting sequence number (int)
        output_dir: Output directory for generated files (Path or str, optional)
        layout: Jekyll layout name (str)
        prompt_file: Custom LLM prompt filename (str, optional)
        jekyll_file: Custom Jekyll draft filename (str, optional)

    Returns:
        dict: Paths to generated files:
            - prompt_path: Path to LLM prompt file
            - jekyll_path: Path to Jekyll draft file

    Raises:
        FileNotFoundError: If topics file doesn't exist
        ValueError: If date format is invalid or data is malformed
    """
    topics_file = Path(topics_file)

    # Validate inputs
    if not topics_file.exists():
        raise FileNotFoundError(f"Topics file not found: {topics_file}")

    # Validate date format
    try:
        datetime.strptime(meeting_date, "%Y-%m-%d")
    except ValueError:
        raise ValueError(f"Invalid date format: {meeting_date}. Use YYYY-MM-DD format.")

    # Setup output directory
    if output_dir:
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
    else:
        output_dir = topics_file.parent

    # Setup output filenames
    prompt_path = output_dir / (prompt_file or DEFAULT_PROMPT_FILE)
    jekyll_path = output_dir / (jekyll_file or DEFAULT_JEKYLL_DRAFT)

    # Load topics
    print(f"‚ñ∂ Loading topics from {topics_file}...")
    try:
        topics = json.loads(topics_file.read_text(encoding="utf-8"))
        if not isinstance(topics, list):
            raise ValueError("Topics file must contain a JSON array")
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON in topics file: {e}") from e

    # Build metadata (deterministic, not from LLM)
    print("‚ñ∂ Building metadata...")
    metadata = build_meeting_metadata(topics, meeting_date, meeting_number, layout)

    # Prepare topics for LLM
    print("‚ñ∂ Preparing topics for LLM...")
    prepared_topics = prepare_topics_for_llm(topics)

    # Generate LLM prompt
    print("‚ñ∂ Generating LLM prompt...")
    llm_prompt = build_llm_prompt(prepared_topics)
    prompt_path.write_text(llm_prompt, encoding="utf-8")

    # Generate Jekyll draft
    print("‚ñ∂ Generating Jekyll draft...")
    jekyll_content = build_jekyll_draft(metadata)
    jekyll_path.write_text(jekyll_content, encoding="utf-8")

    # Print summary
    print("\n‚úÖ Article generation complete!")
    print(f"\nüìù LLM Prompt: {prompt_path}")
    print(f"üìÑ Jekyll Draft: {jekyll_path}")

    print("\nüìã Metadata:")
    print(json.dumps(metadata, indent=2, ensure_ascii=False))

    print("\n‚ö° Next steps:")
    print("  1. Send LLM prompt to your preferred LLM")
    print("  2. Copy LLM output to Jekyll draft")
    print("  3. Review and publish")

    return {
        "prompt_path": str(prompt_path),
        "jekyll_path": str(jekyll_path),
        "metadata": metadata
    }


def main():
    """
    Main entry point for article generator.

    Generates LLM prompts and Jekyll drafts from analyzed meeting topics.

    Command line arguments:
        --topics, -i: Path to topics JSON file from analyzer (required)
        --date, -d: Meeting date in YYYY-MM-DD format (required)
        --number, -n: Meeting sequence number (required)
        --outdir, -o: Output directory (default: same as topics file)
        --layout: Jekyll layout name (default: meeting)
        --prompt-file: Custom LLM prompt filename
        --jekyll-file: Custom Jekyll draft filename

    Outputs:
        - llm_prompt.txt: Structured prompt for LLM
        - jekyll_draft.md: Jekyll page template with placeholders
    """
    parser = argparse.ArgumentParser(
        description="Generate meeting article from analyzed topics",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic usage
  python generate_meeting_article.py \\
    --topics output/llm_input.json \\
    --date 2025-01-15 \\
    --number 23

  # Custom output directory
  python generate_meeting_article.py \\
    -i output/llm_input.json \\
    -d 2025-01-15 \\
    -n 23 \\
    -o articles/

  # Custom Jekyll layout
  python generate_meeting_article.py \\
    -i output/llm_input.json \\
    -d 2025-01-15 \\
    -n 23 \\
    --layout custom-meeting

Workflow:
  1. Run analyzer: analyze_meeting_topics.py --file transcript.txt
  2. Run this tool: generate_meeting_article.py --topics llm_input.json --date YYYY-MM-DD --number N
  3. Send llm_prompt.txt to LLM (Claude, GPT, etc.)
  4. Copy LLM output into jekyll_draft.md
  5. Review and publish
        """
    )

    parser.add_argument(
        "--topics", "-i",
        type=Path,
        required=True,
        help="Input topics JSON file (from analyzer)"
    )

    parser.add_argument(
        "--date", "-d",
        type=str,
        required=True,
        help="Meeting date in YYYY-MM-DD format"
    )

    parser.add_argument(
        "--number", "-n",
        type=int,
        required=True,
        help="Meeting sequence number"
    )

    parser.add_argument(
        "--outdir", "-o",
        type=Path,
        help="Output directory (default: same as topics file)"
    )

    parser.add_argument(
        "--layout",
        type=str,
        default=DEFAULT_LAYOUT,
        help=f"Jekyll layout name (default: {DEFAULT_LAYOUT})"
    )

    parser.add_argument(
        "--prompt-file",
        type=str,
        help=f"Custom LLM prompt filename (default: {DEFAULT_PROMPT_FILE})"
    )

    parser.add_argument(
        "--jekyll-file",
        type=str,
        help=f"Custom Jekyll draft filename (default: {DEFAULT_JEKYLL_DRAFT})"
    )

    args = parser.parse_args()

    # Run article generation
    try:
        generate_article(
            topics_file=args.topics,
            meeting_date=args.date,
            meeting_number=args.number,
            output_dir=args.outdir,
            layout=args.layout,
            prompt_file=args.prompt_file,
            jekyll_file=args.jekyll_file
        )
    except Exception as e:
        print(f"‚ùå Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
